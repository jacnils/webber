#include <iostream>
#include <sstream>
#include <webber.hpp>
#include <db_abstract.hpp>
// prebuilt is generated by CMake; creating the build directory should resolve any errors here
#include <prebuilt.hpp> // NOLINT
#include <limhamn/argument_manager/argument_manager.hpp>
#include <limhamn/http/http_server.hpp>
#include <limhamn/http/http_utils.hpp>
#include <yaml-cpp/yaml.h>

std::string webber::open_file(const std::string& file_path) {
    std::ifstream file{file_path};
    std::string content{std::istreambuf_iterator<char>{file}, std::istreambuf_iterator<char>{}};
    file.close();
    return content;
}

void webber::server_init() { // NOLINT
    try {
#ifdef WEBBER_ENABLE_SQLITE
#ifndef WEBBER_ENABLE_POSTGRESQL
        settings.enabled_database = false;
#endif
#endif

#ifdef WEBBER_ENABLE_POSTGRESQL
#ifndef WEBBER_ENABLE_SQLITE
        settings.enabled_database = true;
#endif
#endif

#if WEBBER_DEBUG
        logger.write_to_log(limhamn::logger::type::notice, "Using database type: " + std::string(settings.enabled_database ? "PostgreSQL" : "SQLite") + "\n");
#endif

        std::shared_ptr<database> database = std::make_shared<webber::database>(settings.enabled_database, [](const std::string& query, bool type) {
            logger.write_to_log(limhamn::logger::type::notice, "Query: " + query + " (type: " + std::string(type ? "PostgreSQL" : "SQLite") + ")\n");
        });

        if (settings.enabled_database) {
#ifdef WEBBER_ENABLE_POSTGRESQL
            database->get_postgres().open(settings.psql_host,
                settings.psql_username,
                settings.psql_password,
                settings.psql_database,
                settings.psql_port);
#endif
        } else {
#ifdef WEBBER_ENABLE_SQLITE
            database->get_sqlite().open(settings.sqlite_database_file);
#endif
        }

        if (!database->good()) {
            fatal = true;
            throw std::runtime_error{"Error opening the database file."};
        }

        setup_database(*database);

        // CHANGEME if 1 no longer corresponds to the admin user type
        needs_setup = database->query("SELECT * FROM users WHERE user_type = 1;").empty();

#ifdef WEBBER_DEBUG
        logger.write_to_log(limhamn::logger::type::notice, "Needs setup: " + std::to_string(needs_setup) + "\n");
#endif

        limhamn::http::server::server(limhamn::http::server::server_settings{
          .port = settings.port,
          .enable_session = true,
          .session_directory = settings.session_directory,
          .session_cookie_name = settings.session_cookie_name,
          .max_request_size = settings.max_request_size,
          .rate_limits = {},
          .blacklisted_ips = settings.blacklisted_ips,
          .whitelisted_ips = settings.whitelisted_ips,
          .default_rate_limit = settings.rate_limit,
          .trust_x_forwarded_for = settings.trust_x_forwarded_for,
          }, [&](const limhamn::http::server::request& request) -> limhamn::http::server::response {
              logger.write_to_log(limhamn::logger::type::access, "Request received from " + request.ip_address + " to " + request.endpoint + " received, handling it.\n");

              static const std::unordered_map<std::string, std::function<limhamn::http::server::response(const limhamn::http::server::request&, webber::database&)>> handlers{
                  {"/css/main.css", get_stylesheet},
                  {"/js/main.js", get_script},
                  {"/api/try_login", get_api_try_login},
                  {"/api/try_register", get_api_try_register},
                  {"/api/user_exists", get_api_user_exists},
                  {"/api/get_settings", get_api_get_settings},
                  {"/api/update_settings", get_api_update_settings},
                  {"/api/get_page", get_api_get_page},
                  {"/api/create_page", get_api_create_page},
                  {"/api/delete_page", get_api_delete_page},
                  {"/api/update_page", get_api_update_page},
              };

              // if setup needed, return setup page or setup api
              if (needs_setup) {
                  return request.endpoint != "/api/try_setup" ? get_setup_page(request, *database) : get_api_try_setup(request, *database);
              }

              // standard pages
              for (const auto& [path, handler] : handlers) {
                  if (request.endpoint.find(path) != std::string::npos) {
                      return handler(request, *database);
                  }
              }

              // handle custom paths
              for (const auto& it : settings.custom_paths) {
                  if (it.first == request.endpoint) {
                      limhamn::http::server::response response{};

                      if (!std::filesystem::is_regular_file(it.second)) {
                          break;
                      }

                      response.body = open_file(it.second);
                      response.http_status = 200;
                      response.content_type = limhamn::http::utils::get_appropriate_content_type(it.first);

                      return response;
                  }
              }

              std::string file = request.endpoint;
              if (file.find("/download/") != std::string::npos) {
                  std::filesystem::path file_path = file.substr(10); // remove /download/
                  file_path = file_path.lexically_normal(); // normalize the path

                  if (webber::is_file(*database, file_path.string())) {
                      const auto& h = webber::download_file(*database, webber::UserProperties{
                          .username = request.session.contains("username") ? request.session.at("username") : "",
                          .ip_address = request.ip_address,
                          .user_agent = request.user_agent,
                      }, file_path.string());

                      limhamn::http::server::response response{};

                      response.body = open_file(h.path);
                      response.http_status = 200;
                      response.content_type = limhamn::http::utils::get_appropriate_content_type(h.name);

                      if (settings.preview_files) {
                          response.headers.push_back({"Content-Disposition", "inline; filename=\"" + h.name + "\""});
                      } else {
                          response.headers.push_back({"Content-Disposition", "attachment; filename=\"" + h.name + "\""});
                      }

                      return response;
                  }
              }

              // TODO: user specified paths

              // fallback is index, javascript will handle the rest, such as 404
              return get_index_page(request, *database);
          });
    } catch (const std::exception& e) {
        if (std::string(e.what()).find("Address already in use") != std::string::npos) {
            fatal = true;
            logger.write_to_log(limhamn::logger::type::error, "The port is already in use. Please try again later.\n");
        } else {
            logger.write_to_log(limhamn::logger::type::error, "An error occurred: " + std::string{e.what()} + "\n");
        }

        if (fatal) {
            logger.write_to_log(limhamn::logger::type::error, "The last error was too severe to recover, and the server will now halt.\n");
            std::exit(EXIT_FAILURE);
        }

        if (settings.halt_on_error) {
            logger.write_to_log(limhamn::logger::type::error, "Halting the server due to an error.\n");
            std::exit(EXIT_FAILURE);
        }

        server_init();
    }
}

webber::Settings webber::load_settings(const std::string& _config) {
    std::string config = _config;
    if (config.empty()) {
        const char* env = std::getenv("WEBBER_CONFIG_FILE");

        if (env != nullptr) {
            config = env;
        }
    } else {
    #ifdef WEBBER_DEBUG
        config = "./config.yaml";
    #else
        config = "/etc/webber/config.yaml";
    #endif
    }

    if (!std::filesystem::exists(config)) {
        std::cerr << "Warning: The configuration file does not exist. Using default settings:\n";
        const auto remove_all_comments = [](const std::string& str) -> std::string {
            std::string ret;
            std::istringstream ss{str};
            std::string line;
            while (std::getline(ss, line)) {
                if (line.find('#') != std::string::npos) {
                    line = line.substr(0, line.find('#'));
                }
                ret += line + "\n";
            }
            while (ret.find("\n\n") != std::string::npos) {
                ret = ret.substr(0, ret.find("\n\n")) + ret.substr(ret.find("\n\n") + 1);
            }
            return ret;
        };

        std::cerr << remove_all_comments(get_default_config());
        return {};
    }

#ifdef WEBBER_DEBUG
    std::cout << "Loading configuration file: " << config << "\n";
#endif

    try {
        YAML::Node y = YAML::LoadFile(config);

        if (y["logger"]["output_to_std"]) settings.output_to_std = y["logger"]["output_to_std"].as<bool>();
        if (y["logger"]["halt_on_error"]) settings.halt_on_error = y["logger"]["halt_on_error"].as<bool>();
        if (y["logger"]["log_access_to_file"]) settings.log_access_to_file = y["logger"]["log_access_to_file"].as<bool>();
        if (y["logger"]["log_warning_to_file"]) settings.log_warning_to_file = y["logger"]["log_warning_to_file"].as<bool>();
        if (y["logger"]["log_error_to_file"]) settings.log_error_to_file = y["logger"]["log_error_to_file"].as<bool>();
        if (y["logger"]["log_notice_to_file"]) settings.log_notice_to_file = y["logger"]["log_notice_to_file"].as<bool>();
        if (y["account"]["username_min_length"]) settings.username_min_length = y["account"]["username_min_length"].as<std::size_t>();
        if (y["account"]["username_max_length"]) settings.username_max_length = y["account"]["username_max_length"].as<std::size_t>();
        if (y["account"]["password_min_length"]) settings.password_min_length = y["account"]["password_min_length"].as<std::size_t>();
        if (y["account"]["password_max_length"]) settings.password_max_length = y["account"]["password_max_length"].as<std::size_t>();
        if (y["account"]["allowed_characters"]) settings.allowed_characters = y["account"]["allowed_characters"].as<std::string>();
        if (y["account"]["allow_all_characters"]) settings.allow_all_characters = y["account"]["allow_all_characters"].as<bool>();
        if (y["filesystem"]["session_directory"]) settings.session_directory = y["filesystem"]["session_directory"].as<std::string>();
        if (y["filesystem"]["data_directory"]) settings.data_directory = y["filesystem"]["data_directory"].as<std::string>();
        if (y["filesystem"]["temp_directory"]) settings.temp_directory = y["filesystem"]["temp_directory"].as<std::string>();
        if (y["filesystem"]["access_file"]) settings.access_file = y["filesystem"]["access_file"].as<std::string>();
        if (y["filesystem"]["warning_file"]) settings.warning_file = y["filesystem"]["warning_file"].as<std::string>();
        if (y["filesystem"]["error_file"]) settings.error_file = y["filesystem"]["error_file"].as<std::string>();
        if (y["filesystem"]["notice_file"]) settings.notice_file = y["filesystem"]["notice_file"].as<std::string>();
        if (y["database"]["type"]) settings.enabled_database = y["database"]["type"].as<std::string>() == "postgresql";
        if (y["sqlite3"]["sqlite_database_file"]) settings.sqlite_database_file = y["sqlite3"]["sqlite_database_file"].as<std::string>();
        if (y["postgresql"]["database"]) settings.psql_database = y["postgresql"]["database"].as<std::string>();
        if (y["postgresql"]["username"]) settings.psql_username = y["postgresql"]["username"].as<std::string>();
        if (y["postgresql"]["password"]) settings.psql_password = y["postgresql"]["password"].as<std::string>();
        if (y["postgresql"]["host"]) settings.psql_host = y["postgresql"]["host"].as<std::string>();
        if (y["postgresql"]["port"]) settings.psql_port = y["postgresql"]["port"].as<int>();
        if (y["client"]["session_cookie_name"]) settings.session_cookie_name = y["client"]["session_cookie_name"].as<std::string>();
        if (y["site"]["url"]) settings.site_url = y["site"]["url"].as<std::string>();
        if (y["upload"]["max_request_size"]) settings.max_request_size = y["upload"]["max_request_size"].as<int64_t>();
        if (y["upload"]["max_file_size_hash"]) settings.max_file_size_hash = y["upload"]["max_file_size_hash"].as<int64_t>();
        if (y["download"]["preview_files"]) settings.preview_files = y["download"]["preview_files"].as<bool>();
        if (y["http"]["port"]) settings.port = y["http"]["port"].as<int>();
        if (y["http"]["trust_x_forwarded_for"]) settings.trust_x_forwarded_for = y["http"]["trust_x_forwarded_for"].as<bool>();
        if (y["http"]["max_requests_per_ip_per_minute"]) settings.rate_limit = y["http"]["max_requests_per_ip_per_minute"].as<int>();
        if (y["http"]["whitelisted_ips"]) {
            for (const auto& ip : y["http"]["whitelisted_ips"]) {
                settings.whitelisted_ips.emplace_back(ip.as<std::string>());
            }
        }
        if (y["http"]["blacklisted_ips"]) {
            for (const auto& ip : y["http"]["blacklisted_ips"]) {
                settings.blacklisted_ips.emplace_back(ip.as<std::string>());
            }
        }
        if (y["paths"]) {
            for (const auto& n : y["paths"]) {
                auto first = n.first.as<std::string>();
                auto second = n.second.as<std::string>();
                if (std::filesystem::is_regular_file(second)) {
                    settings.custom_paths.emplace_back(n.first.as<std::string>(), n.second.as<std::string>());
                } else {
                    if (second.back() == '*') {
                        for (const auto& entry : std::filesystem::directory_iterator(second.substr(0, second.size() - 1))) {
                            settings.custom_paths.emplace_back(first + entry.path().filename().string(), entry.path().string());
                        }
                    } else {
                        logger.write_to_log(limhamn::logger::type::warning, "The file " + n.first.as<std::string>() + " does not exist. Skipping.\n");
                    }
                }
            }
        }
    } catch (const YAML::Exception& e) {
        std::cerr << "Error loading the configuration file: " << e.what() << "\n";
        std::exit(EXIT_FAILURE);
    }

    return settings;
}

std::string webber::get_default_config() {
    std::stringstream ss;

    ss << "# webber Configuration File\n";
    ss << "#\n";
    ss << "# This is the configuration file for webber version " << WEBBER_VERSION << ". You can change the settings to your liking.\n";
    ss << "# It should be placed in /etc/webber/, named config.yaml. If you want to use a different file, you can set the WEBBER_CONFIG_FILE environment variable or pass --config-file.\n";
    ss << "#\n";
    ss << "# Logger options:\n";
    ss << "#   output_to_std: Whether to output log messages to the standard output.\n";
    ss << "#   halt_on_error: Whether to halt the server on an error.\n";
    ss << "#   log_access_to_file: Whether to log access messages to a file.\n";
    ss << "#   log_warning_to_file: Whether to log warning messages to a file.\n";
    ss << "#   log_error_to_file: Whether to log error messages to a file.\n";
    ss << "#   log_notice_to_file: Whether to log notice messages to a file.\n";
    ss << "logger:\n";
    ss << "  output_to_std: " << (webber::settings.output_to_std ? "true" : "false") << "\n";
    ss << "  halt_on_error: " << (webber::settings.halt_on_error ? "true" : "false") << "\n";
    ss << "  log_access_to_file: " << (webber::settings.log_access_to_file ? "true" : "false") << "\n";
    ss << "  log_warning_to_file: " << (webber::settings.log_warning_to_file ? "true" : "false") << "\n";
    ss << "  log_error_to_file: " << (webber::settings.log_error_to_file ? "true" : "false") << "\n";
    ss << "  log_notice_to_file: " << (webber::settings.log_notice_to_file ? "true" : "false") << "\n";
    ss << "\n";
    ss << "# Account options:\n";
    ss << "#   username_min_length: The minimum length of a username.\n";
    ss << "#   username_max_length: The maximum length of a username.\n";
    ss << "#   password_min_length: The minimum length of a password.\n";
    ss << "#   password_max_length: The maximum length of a password.\n";
    ss << "#   allowed_characters: The characters allowed in a username or password.\n";
    ss << "#   allow_all_characters: Whether to allow all characters in a username or password.\n";
    ss << "account:\n";
    ss << "  username_min_length: " << webber::settings.username_min_length << "\n";
    ss << "  username_max_length: " << webber::settings.username_max_length << "\n";
    ss << "  password_min_length: " << webber::settings.password_min_length << "\n";
    ss << "  password_max_length: " << webber::settings.password_max_length << "\n";
    ss << "  allowed_characters: \"" << webber::settings.allowed_characters << "\"\n";
    ss << "  allow_all_characters: " << (webber::settings.allow_all_characters ? "true" : "false") << "\n";
    ss << "\n";
    ss << "# HTTP options:\n";
    ss << "#   port: The port to run the web server on.\n";
    ss << "#   trust_x_forwarded_for: Whether to trust the X-Forwarded-For header. ONLY ENABLE IF YOU'RE USING A REVERSE PROXY THAT YOU TRUST!\n";
    ss << "#   max_requests_per_ip_per_minute: The maximum number of requests per IP per minute.\n";
    ss << "#   whitelisted_ips: A list of whitelisted IPs.\n";
    ss << "#   blacklisted_ips: A list of blacklisted IPs.\n";
    ss << "http:\n";
    ss << "  port: " << webber::settings.port << "\n";
    ss << "  trust_x_forwarded_for: " << (webber::settings.trust_x_forwarded_for ? "true" : "false") << "\n";
    ss << "  max_requests_per_ip_per_minute: " << webber::settings.rate_limit << "\n";
    ss << "  whitelisted_ips:\n";
    for (const auto& ip : webber::settings.whitelisted_ips) {
        ss << "    - " << ip << "\n";
    }
    ss << "  blacklisted_ips:\n";
    for (const auto& ip : webber::settings.blacklisted_ips) {
        ss << "    - " << ip << "\n";
    }
    ss << "\n";
    ss << "# Filesystem options:\n";
    ss << "#   session_directory: The directory where session files are stored.\n";
    ss << "#   data_directory: The directory where data files are stored.\n";
    ss << "#   temp_directory: The directory where temporary files are stored.\n";
    ss << "#   access_file: The path to the access log file.\n";
    ss << "#   warning_file: The path to the warning log file.\n";
    ss << "#   error_file: The path to the error log file.\n";
    ss << "#   notice_file: The path to the notice log file.\n";
    ss << "filesystem:\n";
    ss << "  session_directory: \"" << webber::settings.session_directory << "\"\n";
    ss << "  data_directory: \"" << webber::settings.data_directory << "\"\n";
    ss << "  temp_directory: \"" << webber::settings.temp_directory << "\"\n";
    ss << "  access_file: \"" << webber::settings.access_file << "\"\n";
    ss << "  warning_file: \"" << webber::settings.warning_file << "\"\n";
    ss << "  error_file: \"" << webber::settings.error_file << "\"\n";
    ss << "  notice_file: \"" << webber::settings.notice_file << "\"\n";
    ss << "\n";
    ss << "# Database options:\n";
    ss << "#   type: The type of database to use. (sqlite3, postgresql)\n";
    ss << "database:\n";
    ss << "  type: \"" << (webber::settings.enabled_database ? "postgresql" : "sqlite3") << "\"\n";
    ss << "\n";
    ss << "# SQLite3 options:\n";
    ss << "#   sqlite_database_file: The path to the SQLite3 database file.\n";
    ss << "sqlite3:\n";
    ss << "  sqlite_database_file: \"" << webber::settings.sqlite_database_file << "\"\n";
    ss << "\n";
    ss << "# PostgreSQL options:\n";
    ss << "#   database: The PostgreSQL database.\n";
    ss << "#   username: The PostgreSQL username.\n";
    ss << "#   password: The PostgreSQL password.\n";
    ss << "#   host: The PostgreSQL host.\n";
    ss << "#   port: The PostgreSQL port.\n";
    ss << "postgresql:\n";
    ss << "  database: \"" << webber::settings.psql_database << "\"\n";
    ss << "  username: \"" << webber::settings.psql_username << "\"\n";
    ss << "  password: \"" << webber::settings.psql_password << "\"\n";
    ss << "  host: \"" << webber::settings.psql_host << "\"\n";
    ss << "  port: " << webber::settings.psql_port << "\n";
    ss << "\n";
    ss << "# Client options:\n";
    ss << "#   session_cookie_name: The name of the session cookie.\n";
    ss << "client:\n";
    ss << "  session_cookie_name: \"" << webber::settings.session_cookie_name << "\"\n";
    ss << "\n";
    ss << "# Site options:\n";
    ss << "#   url: The URL of the site (e.g. https://example.com).\n";
    ss << "site:\n";
    ss << "  url: \"" << webber::settings.site_url << "\"\n";
    ss << "\n";
    ss << "# Upload options:\n";
    ss << "#   max_request_size: The maximum request size in bytes. Any larger will be rejected by the server\n";
    ss << "#   max_file_size_hash: The maximum file size in bytes that can be hashed. Any larger will not be hashed.\n";
    ss << "upload:\n";
    ss << "  max_request_size: " << webber::settings.max_request_size << "\n";
    ss << "  max_file_size_hash: " << webber::settings.max_file_size_hash << "\n";
    ss << "\n";
    ss << "# Download options:\n";
    ss << "#   preview_files: Whether to preview files in the browser when downloading them.\n";
    ss << "download:\n";
    ss << "  preview_files: " << (webber::settings.preview_files ? "true" : "false") << "\n";
    ss << "\n";
    ss << "# Custom paths:\n";
    ss << "#   These are paths to files that are not in the default directories.\n";
    ss << "#   The first path is the virtual path, and the second path is the actual path.\n";
    ss << "paths:\n";
    for (const auto& p : webber::settings.custom_paths) {
        ss << "  \"" << p.first << "\": \"" << p.second << "\"\n";
    }
    return ss.str();
}

void webber::prepare_wd() {
    const auto log_error = [](const std::string& error_msg) {
        webber::logger.write_to_log(limhamn::logger::type::error, error_msg);
        std::exit(EXIT_FAILURE);
    };
    const auto create_directory = [](const std::string& path) -> bool {
        try {
            if (path == "." || path == "..") return true;
            if (std::filesystem::is_directory(path)) return true;
            if (!std::filesystem::create_directories(path)) {
                return false;
            }

            return true;
        } catch (const std::filesystem::filesystem_error&) {
            return false;
        }
    };
    const auto check_if_exists = [](const std::string& path) -> bool {
        return std::filesystem::exists(path);
    };
    const auto remove_all_in_directory = [&check_if_exists](const std::string& path) -> void {
        if (!check_if_exists(path)) {
            return;
        }

        for (const auto& entry : std::filesystem::directory_iterator(path)) {
#if WEBBER_DEBUG
            webber::logger.write_to_log(limhamn::logger::type::notice, "Removing: " + entry.path().string() + "\n");
#endif
            std::filesystem::remove(entry.path());
        }
    };

    if (!check_if_exists(webber::settings.session_directory)) {
        webber::logger.write_to_log(limhamn::logger::type::notice, "The session directory does not exist. Creating it.\n");
        if (!create_directory(webber::settings.session_directory)) {
            log_error("Failed to create the session directory. Do I have adequate permissions? Unrecoverable error.\n");
        }
        webber::logger.write_to_log(limhamn::logger::type::notice, "The session directory was created.\n");
    }

    if (!check_if_exists(webber::settings.data_directory)) {
        webber::logger.write_to_log(limhamn::logger::type::notice, "The data directory does not exist. Creating it.\n");
        if (!create_directory(webber::settings.data_directory)) {
            log_error("Failed to create the data directory. Do I have adequate permissions? Unrecoverable error.\n");
        }
        webber::logger.write_to_log(limhamn::logger::type::notice, "The data directory was created.\n");
    }

    if (!check_if_exists(webber::settings.temp_directory)) {
        webber::logger.write_to_log(limhamn::logger::type::notice, "The temp directory does not exist. Creating it.\n");
        if (!create_directory(webber::settings.temp_directory)) {
            log_error("Failed to create the temp directory. Do I have adequate permissions? Unrecoverable error.\n");
        }
        webber::logger.write_to_log(limhamn::logger::type::notice, "The temp directory was created.\n");
    }

    if (!check_if_exists(webber::settings.sqlite_database_file) && !webber::settings.enabled_database) {
        std::filesystem::path database_file_path{webber::settings.sqlite_database_file};
        std::filesystem::path database_file_directory{database_file_path.parent_path()};

        webber::logger.write_to_log(limhamn::logger::type::notice, "The database file directory does not exist. Creating it.\n");
        if (!create_directory(database_file_directory)) {
            log_error("Failed to create the database file directory. Do I have adequate permissions? Unrecoverable error.\n");
        }
        webber::logger.write_to_log(limhamn::logger::type::notice, "The database file directory was created.\n");
    }

    remove_all_in_directory(webber::settings.temp_directory);
    remove_all_in_directory(webber::settings.session_directory);

    // some initial files
    if (!check_if_exists(settings.data_directory + "/" + "index.html")) {
        std::ofstream of(settings.data_directory + "/" + "index.html");
        of << webber::index_page;
        of.close();
    }
    if (!check_if_exists(settings.data_directory + "/" + "setup.html")) {
        std::ofstream of(settings.data_directory + "/" + "setup.html");
        of << webber::setup_page;
        of.close();
    }
    if (!check_if_exists(settings.data_directory + "/" + "style.css")) {
        std::ofstream of(settings.data_directory + "/" + "style.css");
        of << webber::index_stylesheet;
        of.close();
    }
    if (!check_if_exists(settings.data_directory + "/" + "script.js")) {
        std::ofstream of(settings.data_directory + "/" + "script.js");
        of << webber::index_javascript;
        of.close();
    }
    if (!check_if_exists(settings.data_directory + "/" + "settings.json")) {
        std::ofstream of(settings.data_directory + "/" + "settings.json");
        of << webber::default_settings;
        of.close();
    }
}

void webber::clean_data() {
    std::cout << "This will delete ALL data in the session, temp and data directories. This could very well be unrecoverable and may cause data loss and breakage. Are you sure you want to continue? More than likely, this is not the solution to your problems. (y/N) ";
    std::string response;
    std::getline(std::cin, response);

    if (response != "y" && response != "Y") {
        std::cout << "Aborting.\n";
        std::exit(EXIT_SUCCESS);
    }

    const auto check_if_exists = [](const std::string& path) -> bool {
        return std::filesystem::exists(path);
    };
    const auto remove_all_in_directory = [&check_if_exists](const std::string& path) -> void {
        if (!check_if_exists(path)) {
            return;
        }

        for (const auto& entry : std::filesystem::directory_iterator(path)) {
#if WEBBER_DEBUG
            webber::logger.write_to_log(limhamn::logger::type::notice, "Removing: " + entry.path().string() + "\n");
#endif
            std::filesystem::remove(entry.path());
        }
    };

    remove_all_in_directory(webber::settings.temp_directory);
    remove_all_in_directory(webber::settings.session_directory);
    remove_all_in_directory(webber::settings.data_directory);
}

void webber::print_help() {
    std::cout << "webber [options]\n";
    std::cout << "  -h, --help               Display help information\n";
    std::cout << "  -v, --version            Display the version number\n";
}

int main(int argc, char** argv) {
    using namespace webber;

#ifdef WEBBER_DEBUG
    std::string config_file{"./config.yaml"};
#else
    std::string config_file{"/etc/webber/config.yaml"};
#endif
    limhamn::argument_manager::argument_manager arg{argc, argv};

    arg.push_back("-h|--help|/h|/help|help", [](const limhamn::argument_manager::collection& c) {webber::print_help(); std::exit(EXIT_SUCCESS);});
    arg.push_back("-v|--version|/v|/version|version", [](const limhamn::argument_manager::collection& c) {std::cout << "Version: " << WEBBER_VERSION << "\n"; std::exit(EXIT_SUCCESS);});
    arg.push_back("-c|--config-file|/c|/config-file", [&](limhamn::argument_manager::collection& c) {
        if (c.arguments.size() <= 1) {
            std::cerr << "The -c/--config flag requires a file to be specified.\n";
            std::exit(EXIT_FAILURE);
        }

        config_file = c.arguments.at(++c.index);
    });
    arg.execute([](const std::string&) {});

    settings = webber::load_settings(config_file);

    arg = limhamn::argument_manager::argument_manager(argc, argv);

    arg.push_back("-h|--help|/h|/help|help", [](const limhamn::argument_manager::collection& c) {});
    arg.push_back("-v|--version|/v|/version|version", [](const limhamn::argument_manager::collection& c) {});
    arg.push_back("-c|--config-file|/c|/config-file", [](limhamn::argument_manager::collection& c) {
        ++c.index;
    });

    arg.push_back("-p|--port|/p|/port", [&](limhamn::argument_manager::collection& c) {
        if (c.arguments.size() <= 1) {
            std::cerr << "The -p/--port flag requires a port number to be specified.\n";
            std::exit(EXIT_FAILURE);
        }

        settings.port = std::stoi(c.arguments.at(++c.index));
    });
    arg.push_back("-he|--halt-on-error|/he|/halt-on-error", [&](const limhamn::argument_manager::collection& c) {webber::settings.halt_on_error = true;});
    arg.push_back("-nhe|--no-halt-on-error|/nhe|/no-halt-on-error", [&](const limhamn::argument_manager::collection& c) {webber::settings.halt_on_error = false;});
    arg.push_back("-gc|--generate-config|/gc|/generate-config", [&](const limhamn::argument_manager::collection& c) {std::cout << webber::get_default_config(); std::exit(EXIT_SUCCESS);});
    arg.push_back("-cd|--clean-data|/cd|/clean-data", [&](const limhamn::argument_manager::collection& c) {webber::clean_data(); std::exit(EXIT_SUCCESS);});
    arg.execute([](const std::string& arg) {
        std::cerr << "unknown argument: " << arg << "\n";
        std::exit(EXIT_FAILURE);
    });

    logger.override_properties(
        limhamn::logger::logger_properties{
            .access_log_file = settings.access_file,
            .warning_log_file = settings.warning_file,
            .error_log_file = settings.error_file,
            .notice_log_file = settings.notice_file,
            .output_to_std = settings.output_to_std,
            .log_access_to_file = settings.log_access_to_file,
            .log_warning_to_file = settings.log_warning_to_file,
            .log_error_to_file = settings.log_error_to_file,
            .log_notice_to_file = settings.log_notice_to_file
        }
    );

    prepare_wd();
    server_init();

    return EXIT_SUCCESS;
}